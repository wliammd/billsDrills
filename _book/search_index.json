[["datashape.html", "Chapter 3 Shape of Data 3.1 Making data frames 3.2 Gather, spread, pivoting in the tidyverse 3.3 Gathering steam… 3.4 Spread your wings 3.5 Missing Data: Ich vemisse Dich! 3.6 Pivoting to something new 3.7 Larger structures", " Chapter 3 Shape of Data One of my fundamental stumbling blocks is understanding the shape of data, even “rectangular data” of the sort that Hadley Wickham refers to in R4DS. library(tidyverse) 3.1 Making data frames DF1 &lt;- tibble( Symbol = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), Value = 1:3 ) DF1 ## # A tibble: 3 x 2 ## Symbol Value ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 DF2 &lt;- tibble( Symbol = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;), Value = 4:6 ) DF2 ## # A tibble: 3 x 2 ## Symbol Value ## &lt;chr&gt; &lt;int&gt; ## 1 c 4 ## 2 d 5 ## 3 e 6 DFmerge &lt;- rbind(DF1,DF2) DFmerge ## # A tibble: 6 x 2 ## Symbol Value ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 ## 4 c 4 ## 5 d 5 ## 6 e 6 3.2 Gather, spread, pivoting in the tidyverse The following exercises are based on R4DS. Several simple data tables are available for practice. Check them out: table1 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Note that only table 1 is tidy. Tidy rules the day, making cool things possible. For instance: table1 %&gt;% count(year, wt = cases) ## # A tibble: 2 x 2 ## year n ## &lt;int&gt; &lt;int&gt; ## 1 1999 250740 ## 2 2000 296920 table1 %&gt;% count(year, wt = NULL) ## # A tibble: 2 x 2 ## year n ## &lt;int&gt; &lt;int&gt; ## 1 1999 3 ## 2 2000 3 # BTW, note the difference between the above count and this one: table1 %&gt;% group_by(year) %&gt;% count(cases) ## # A tibble: 6 x 3 ## # Groups: year [2] ## year cases n ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1999 745 1 ## 2 1999 37737 1 ## 3 1999 212258 1 ## 4 2000 2666 1 ## 5 2000 80488 1 ## 6 2000 213766 1 # Or the following group and summarize: table1 %&gt;% group_by(year) %&gt;% summarise(AggCases = sum(cases)) ## # A tibble: 2 x 2 ## year AggCases ## &lt;int&gt; &lt;int&gt; ## 1 1999 250740 ## 2 2000 296920 # Or the following plot (I couldn&#39;t help but embellish this with a fct_reorder--vital to ggplot/geom_line displays,but a trick that I always forget): table1 %&gt;% mutate(country = fct_reorder(country, -population)) %&gt;% ggplot(aes(year, cases)) + geom_line(aes(group = country), colour = &quot;grey50&quot;) + geom_point(aes(colour = country)) An aside on count() and tally(): tally() is a convenient wrapper for summarise that will either call n() or sum(n) depending on whether you’re tallying for the first time, or re-tallying. count() is similar but calls group_by() before and ungroup() after. If the data is already grouped, count() adds an additional group that is removed afterwards. Tidy data is not space-efficient, though. Note how values are reduplicated. This is not an issue in small datasets, but can be a bummer if datasets get large or human data entry is necessary–manually entering demographics is always error-prone. Table 2 on the other hand contains 2 sorts of data in the count column–cases and population. Not only is this less efficient than table 1, it is much more verbose. table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 Table 3 contains unnecessary internal structure. I combines two values into one field. Kudos for transparency, but little is actually gained by doing this, and it complicates analyses. Best to break them apart. table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 Tables 4a and 4b break data into separate structures when a single table would suffice. Many database tables will be arranged like this. However, to perform calculations on data from each table, it can be better to weld the tables into a single structure. table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4b ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 3.3 Gathering steam… Table 4a has a key field–the year–and a value field–cases. To bring the key down into the table, we gather it: table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 tidy4a &lt;- table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) tidy4a ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Brazil 1999 37737 ## 3 China 1999 212258 ## 4 Afghanistan 2000 2666 ## 5 Brazil 2000 80488 ## 6 China 2000 213766 Note that we replace column names that should be data fields with a key (in this example we call it “year”), and the corresponding data held in table4a with a value (in this example “cases”). The same thing can be done with 4b, except now the value is population. table4b ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 tidy4b &lt;- table4b %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;population&quot;) tidy4b ## # A tibble: 6 x 3 ## country year population ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 19987071 ## 2 Brazil 1999 172006362 ## 3 China 1999 1272915272 ## 4 Afghanistan 2000 20595360 ## 5 Brazil 2000 174504898 ## 6 China 2000 1280428583 Note that we get new key and value columns and the gathered columns are dropped. This has the effect of gathering them down into more rows. It should be noted that many examples of gathering are not written in this way. By default, the key and value simply dropped into the correct part of the gather(). Columns that are not part of the gather are then exempted by negation. table4b %&gt;% gather(year, cases, -country) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 19987071 ## 2 Brazil 1999 172006362 ## 3 China 1999 1272915272 ## 4 Afghanistan 2000 20595360 ## 5 Brazil 2000 174504898 ## 6 China 2000 1280428583 David Robinson has even shown examples where he simply uses gather(key, value, -exemptedColumn) (see his YouTube at https://www.youtube.com/watch?v=KzRP40PzopY). The two new tidy tables are joined as follows: left_join(tidy4a, tidy4b) ## Joining, by = c(&quot;country&quot;, &quot;year&quot;) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Brazil 1999 37737 172006362 ## 3 China 1999 212258 1272915272 ## 4 Afghanistan 2000 2666 20595360 ## 5 Brazil 2000 80488 174504898 ## 6 China 2000 213766 1280428583 David Robinson shows in this bit https://www.youtube.com/watch?v=KzRP40PzopY (about 8m 30s into the YouTube) that you don’t need to make the key and value explicit, and also that you can exempt some columns from the process. 3.4 Spread your wings So spread is the opposite of gather. Consider Table 2. table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 Now our task is to spread cases and population from the type column into their own columns. In table2 the type column should be distributed into variable with their own columns. Note that this has the effect of spreading table into more columns. table2 %&gt;% spread(key = type, value = count) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Hadley provides an interesting example that shows how gather and spread are NOT perfect compliments. stocks &lt;- tibble( year = c(2015, 2015, 2016, 2016), half = c( 1, 2, 1, 2), return = c(1.88, 0.59, 0.92, 0.17) ) stocks ## # A tibble: 4 x 3 ## year half return ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015 1 1.88 ## 2 2015 2 0.59 ## 3 2016 1 0.92 ## 4 2016 2 0.17 stocks %&gt;% spread(year, return) %&gt;% gather(&quot;year&quot;, &quot;return&quot;, `2015`:`2016`) ## # A tibble: 4 x 3 ## half year return ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2015 1.88 ## 2 2 2015 0.59 ## 3 1 2016 0.92 ## 4 2 2016 0.17 Note how the correct columns are in place, but the year column is now character data. 3.5 Missing Data: Ich vemisse Dich! Hadley provides a different stock example: stocks &lt;- tibble( year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016), qtr = c( 1, 2, 3, 4, 2, 3, 4), return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66) ) stocks ## # A tibble: 7 x 3 ## year qtr return ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015 1 1.88 ## 2 2015 2 0.59 ## 3 2015 3 0.35 ## 4 2015 4 NA ## 5 2016 2 0.92 ## 6 2016 3 0.17 ## 7 2016 4 2.66 Hadley points out that 2 data points are missing in this data set: one explicit and one implicit. One way to think about the difference is with this Zen-like koan: An explicit missing value is the presence of an absence; an implicit missing value is the absence of a presence. The implicitly missing value here can be made explicit by spreading the years. stocks %&gt;% spread(year, return) ## # A tibble: 4 x 3 ## qtr `2015` `2016` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1.88 NA ## 2 2 0.59 0.92 ## 3 3 0.35 0.17 ## 4 4 NA 2.66 Note exactly how this works: the rows are now determined by qtr. The 2015 4th quarter value, explicitly NA before, remains NA. Now, however, when 2016 is spread as a variable, the gap in quarter 1 is revealed. These NA’s can be removed by gathering the data back up using na.rm = TRUE. stocks %&gt;% spread(year, return) %&gt;% gather(year, return, `2015`:`2016`, na.rm = TRUE) ## # A tibble: 6 x 3 ## qtr year return ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2015 1.88 ## 2 2 2015 0.59 ## 3 3 2015 0.35 ## 4 2 2016 0.92 ## 5 3 2016 0.17 ## 6 4 2016 2.66 3.5.1 You complete(me) The complete() function is also an important way to make missing values explicit. &lt; complete() takes a set of columns, and finds all unique combinations. It then ensures the original dataset contains all those values, filling in explicit NAs where necessary stocks ## # A tibble: 7 x 3 ## year qtr return ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015 1 1.88 ## 2 2015 2 0.59 ## 3 2015 3 0.35 ## 4 2015 4 NA ## 5 2016 2 0.92 ## 6 2016 3 0.17 ## 7 2016 4 2.66 stocks %&gt;% complete(year, qtr) ## # A tibble: 8 x 3 ## year qtr return ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015 1 1.88 ## 2 2015 2 0.59 ## 3 2015 3 0.35 ## 4 2015 4 NA ## 5 2016 1 NA ## 6 2016 2 0.92 ## 7 2016 3 0.17 ## 8 2016 4 2.66 3.5.2 fill(ing) in the gaps While complete() can make explicit the missing values, fill() lets you address a particular type of missing value. Here, the last observation is carried forward. This is very common in data sets. treatment &lt;- tribble( ~ person, ~ treatment, ~response, &quot;Derrick Whitmore&quot;, 1, 7, NA, 2, 10, NA, 3, 9, &quot;Katherine Burke&quot;, 1, 4 ) treatment ## # A tibble: 4 x 3 ## person treatment response ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Derrick Whitmore 1 7 ## 2 &lt;NA&gt; 2 10 ## 3 &lt;NA&gt; 3 9 ## 4 Katherine Burke 1 4 treatment %&gt;% fill(person) ## # A tibble: 4 x 3 ## person treatment response ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Derrick Whitmore 1 7 ## 2 Derrick Whitmore 2 10 ## 3 Derrick Whitmore 3 9 ## 4 Katherine Burke 1 4 3.6 Pivoting to something new These are great exercises, but gather() and spread() are being upgraded to pivot_longer() and pivot_wider(). See https://www.r-bloggers.com/data-pivoting-with-tidyr/ table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4a_long &lt;- table4a %&gt;% pivot_longer( `1999`:`2000`, names_to = &quot;year&quot;, values_to = &quot;value&quot; ) table4a_long ## # A tibble: 6 x 3 ## country year value ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 table4b_long &lt;- table4b %&gt;% pivot_longer( `1999`:`2000`, names_to = &quot;year&quot;, values_to = &quot;value&quot; ) table4b_long ## # A tibble: 6 x 3 ## country year value ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 19987071 ## 2 Afghanistan 2000 20595360 ## 3 Brazil 1999 172006362 ## 4 Brazil 2000 174504898 ## 5 China 1999 1272915272 ## 6 China 2000 1280428583 This is presumably reversible. table4aNew &lt;- table4a_long %&gt;% pivot_wider( names_from = &quot;year&quot;, values_from = &quot;value&quot; ) table4aNew ## # A tibble: 3 x 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 So they are the same. Table 2 can also be spread()… ahem, pivot_wider()ed. table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table2 %&gt;% pivot_wider( names_from = c(&quot;year&quot;, &quot;type&quot;), values_from = &quot;count&quot; ) ## # A tibble: 3 x 5 ## country `1999_cases` `1999_population` `2000_cases` `2000_population` ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 19987071 2666 20595360 ## 2 Brazil 37737 172006362 80488 174504898 ## 3 China 212258 1272915272 213766 1280428583 Note that, names_from can come from multiple columns. When there are multiple names_from or values_from columns, names_sep will be used to join values together to form column names. 3.7 Larger structures The dataframe feels like a natural place to begin. Many times, though I’ll want to call functions on more than one variable. . . As I struggle to get my feet under me in R, StackOverflow has been a wonderful resource, although the community can be very pissy to newbies. The following post is offers a nice description of the difference between lists and dataframes in R: https://stackoverflow.com/a/15902963/7361502 df &lt;- tibble::tibble( a = rnorm(10), b = rbinom(10, 1, 0.5), c = rchisq(10, df = 6), d = rexp(10, rate = 1) ) map_dbl(df, mean) ## a b c d ## -0.4906316 0.6000000 8.3772907 0.7569727 map_dfc(df, mean) ## # A tibble: 1 x 4 ## a b c d ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.491 0.6 8.38 0.757 map_dfr(df, mean) ## # A tibble: 1 x 4 ## a b c d ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.491 0.6 8.38 0.757 "]]

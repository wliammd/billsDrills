# Modeling {#modeling}

```{r include=FALSE}
library(tidyverse)
library(rpart)
```

## Modeling notes

Notes on/inspired by the Machine Learning with caret in R DataCamp course. I'd like to better understand machine learning, especially as it pertains to classification problems. Most discussions begin with regression examples, so these will also be addressed in order to build a better foundation. This is the general approach of James, Witten, Hastie and Tibshirani in An Introduction to Statistical Learning with Applications in R, too. 


A regression example from the course:

```{r}
library(caret)

model <- train(
  price~., 
  diamonds,
  method = "lm",
  trControl = trainControl(
    method = "cv", 
    number = 10,
    verboseIter = TRUE
  )
)

# Print model to console
model
```

Note that **caret** handles the work of splitting test sets and calculating RMSE. 

Another example from the DataCamp course.

```{r}
library(MASS)

# Fit lm model using 5-fold CV: model
model <- train(
  medv~., 
  Boston,
  method = "lm",
  trControl = trainControl(
    method = "cv", 
    number = 5,
    verboseIter = TRUE
  )
)

# Print model to console
model
```

Cross validation can *itself* be repeated. The following is a 5-fold cross validation repeated 5 times.

```{r}
# Fit lm model using 5 x 5-fold CV: model
model <- train(
  medv ~ ., 
  Boston,
  method = "lm",
  trControl = trainControl(
    method = "repeatedcv", 
    number = 5,
    repeats = 5, 
    verboseIter = TRUE
  )
)

# Print model to console
model

predict(model, Boston)
```

## Classification

### An **rpart** classification example.

```{r}
model <- rpart(
  Species ~ .,
  data = iris,
  method = "class"
)

predicted <- predict(model, iris, type = "class")
predicted
mean(predicted == iris$Species)
```

Study what's going on in **predict()**:

```{r}
?predict.rpart
```

## From the DataCamp course

```{r}
library(mlbench)
data("Sonar")

# First randomize the dataset.
rows <- sample(nrow(Sonar))
Sonar <- Sonar[rows,]

# The split it into testing and training sets. 
split <- round(nrow(Sonar)*0.60)
train <- Sonar[1:split,]
test <- Sonar[(split+1):nrow(Sonar),]

nrow(train)/nrow(Sonar)
```

Let's build a model.

```{r}
model <- glm(
  Class ~ .,
  family = binomial(link = "logit"),
  train
)

p <- predict(model, test, type = "response")
summary(p)

p_class <- as.factor(ifelse(p > 0.1, "M", "R"))

table(p_class, test[["Class"]])

confusionMatrix(p_class, test[["Class"]])
```

Receiver operator curves add a new level of complexity and usefulness. According to Zach Mayer in DataCamp, 

 `trainControl()` in **caret** can use AUC (instead of accuracy), to tune the parameters of your models. The `twoClassSummary()` convenience function allows you to do this easily.

When using `twoClassSummary()`, be sure to always include the argument `classProbs = TRUE` or your model will throw an error! (You cannot calculate AUC with just class predictions. You need to have class probabilities as well.)

```{r}
# Create trainControl object: myControl
myControl <- trainControl(
  method = "cv",
  number = 10,
  summaryFunction = twoClassSummary,
  classProbs = TRUE, # IMPORTANT!
  verboseIter = TRUE
)

# Train glm with custom trainControl: model
model<-train(Class~., data=Sonar, method="glm", trControl=myControl)

# Print model to console
model
```

## Random forest with **caret**

For this set, we'll use the white wine quality dataset from UC Irvine. 

```{r}
wine <- read.csv("http://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv", sep = ";")

glimpse(wine)
# Note that quality is an integer, not a factor. **caret** seems to take this in stride. 

# Fit random forest: model
model <- train(
  quality~.,
  tuneLength = 1,
  data = wine, 
  method = "ranger",
  trControl = trainControl(
    method = "cv", 
    number = 5, 
    verboseIter = TRUE
  )
)

# Print model to console
model

plot(model)
```

Let's try this again with a longer `tuneLength`. This explores more models and potentially finds a better model.

```{r}
model <- train(
  quality~.,
  tuneLength = 10,
  data = wine, 
  method = "ranger",
  trControl = trainControl(
    method = "cv", 
    number = 5, 
    verboseIter = TRUE
  )
)

# Print model to console
model

plot(model)
```

Custom tuning of grids can be used in **caret** by using `tuneGrid()`. While it is the most flexible method for fitting **caret** models and allows complete control over how the model is fit, it requires significant knowledge of the model and dramatically increases run time. 

An example provided by Zach Meyer:

```{r}
library(mlbench)
library(caret)
data("Sonar")
myGrid <- data.frame(mtry = c(2,3,4,5,10,20))

set.seed(42)
model <- train(
  Class~.,
  data = Sonar,
  method = "ranger", 
  tuneGrid = myGrid
)
```

This generates an error currently. Try the following frome DataCamp exercise that followed Zach's video.

```{r}
tuneGrid <- data.frame(
  .mtry = c(2, 3, 7),
  .splitrule = "variance",
  .min.node.size = 5
)

# Fit random forest: model
model <- train(
  quality ~ .,
  tuneGrid = tuneGrid,
  data = wine, 
  method = "ranger",
  trControl = trainControl(
    method = "cv", 
    number = 5, 
    verboseIter = TRUE
  )
)

# Print model to console
model

# Plot model
plot(model)
```

## **glmnet** and `patma` 

I'd like to explore Zach Meyer's teaching on **glmnet** models using my own data. That means dipping into `patmanDx.csv` and pulling out the relative data. 

```{r}
patma <- read_csv("data/patmanDx.csv")
df <- patma %>% 
  select(SF1Median, Pit1Median, TPITMedian, PRLMedian, GHMedian, TSHMedian, LHMedian, FSHMedian, ACTHMedian, ASUMedian, GATA3Median, manDx) %>%
  na.omit()

glimpse(df)
```

That seems to give me what I'm looking for. Let's get to work:

```{r}
myControl <- trainControl(
  method = "cv",
  number = 10,
  summaryFunction = twoClassSummary,
  classProbs = TRUE, #Critical to have this, per Meyers.
  verboseIter = TRUE
)

set.seed(42)
model <- train(
  manDx ~ .,
  df,
  method = "glmnet",
  trControl = myControl
)
```

I note that this throws errors because `manDx` contains NULL cell classes, which are converted to `NULL.`. While this is intended to designate null cell adenoma, I'll need to change this. 